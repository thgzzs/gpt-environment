<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Procedural Sky with Stars (Fog/Void Overlay)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
(() => {
  // --- Canvas Setup ---
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  let cw, ch;
  const offRes = 6;
  const offCanvas = document.createElement("canvas");
  const offCtx = offCanvas.getContext("2d");
  offCtx.imageSmoothingEnabled = true;

  const camera = { x: 0, y: 50, z: 0, yaw: 0, pitch: 0, fov: 1.2, aspect: 1 };
  function resize() {
    cw = canvas.width = window.innerWidth;
    ch = canvas.height = window.innerHeight;
    offCanvas.width = Math.ceil(cw / offRes);
    offCanvas.height = Math.ceil(ch / offRes);
    camera.aspect = cw / ch;
  }
  window.addEventListener("resize", resize);
  resize();

  // --- Mouse Controls ---
  let mouseDown = false, lastX = 0, lastY = 0;
  canvas.addEventListener("mousedown", e => {
    mouseDown = true;
    lastX = e.clientX; 
    lastY = e.clientY;
  });
  canvas.addEventListener("mousemove", e => {
    if (mouseDown) {
      camera.yaw   -= (e.clientX - lastX) * 0.005;
      camera.pitch -= (e.clientY - lastY) * 0.005;
      camera.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, camera.pitch));
      lastX = e.clientX; 
      lastY = e.clientY;
    }
  });
  canvas.addEventListener("mouseup", () => { mouseDown = false; });
  canvas.addEventListener("mouseleave", () => { mouseDown = false; });

  // --- Noise & Helper Functions ---
  const seed = Math.random() * 10000;
  const fract = x => x - Math.floor(x);
  const noise = (x, z) => fract(Math.sin(x*12.9898 + z*78.233 + seed) * 43758.5453);
  const lerp = (a, b, t) => a + (b - a) * t;
  const smoothNoise = (x, z) => {
    const xi = Math.floor(x), zi = Math.floor(z);
    const xf = x - xi, zf = z - zi;
    return lerp(
      lerp(noise(xi, zi), noise(xi+1, zi), xf),
      lerp(noise(xi, zi+1), noise(xi+1, zi+1), xf),
      zf
    );
  };
  const fractalNoise = (x, z, octaves=4) => {
    let total = 0, amplitude = 1, frequency = 1, maxAmp = 0;
    for (let i = 0; i < octaves; i++) {
      total += smoothNoise(x * frequency, z * frequency) * amplitude;
      maxAmp += amplitude;
      amplitude *= 0.5;
      frequency *= 2;
    }
    return total / maxAmp;
  };
  const lerpColor = (a, b, t) => ({
    r: Math.round(lerp(a.r, b.r, t)),
    g: Math.round(lerp(a.g, b.g, t)),
    b: Math.round(lerp(a.b, b.b, t))
  });
  const smoothStep = (edge0, edge1, x) => {
    const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
    return t * t * (3 - 2 * t);
  };

  // --- Scene Parameters ---
  const cloudPlaneY = 170, cloudScale = 0.025, cloudSpeed = 1, threshold = 0.5;
  const voidPlaneY = 0;
  const fogStart = 1, fogEnd = 5000;
  const fogBlend = distance => {
    let t = (distance - fogStart) / (fogEnd - fogStart);
    return Math.max(0, Math.min(1, t * t * (3 - 2 * t)));
  };
  const voidFogStart = 1, voidFogEnd = 2000;
  const voidFogBlend = distance => {
    let t = (distance - voidFogStart) / (voidFogEnd - voidFogStart);
    return Math.max(0, Math.min(1, t * t * (3 - 2 * t)));
  };
  const perspectiveExponent = 0.45;
  const dayCyclePeriod = 60; // seconds

  // --- Sky & Horizon Colors ---
  const daySkyTop    = { r:120, g:180, b:240 };
  const daySkyBottom = { r:165, g:200, b:255 };
  const nightSkyTop    = { r:0,   g:0,   b:20 };
  const nightSkyBottom = { r:10,  g:10,  b:40 };
  const sunriseColor      = { r:255, g:140, b:70 };
  const nightHorizonColor = { r:15,  g:10,  b:30 };
  const softPurple        = { r:180, g:150, b:200 };
  const computeHorizonColor = (dayFactor, skyBottom) => {
    if (dayFactor <= 0.33) {
      return lerpColor(nightHorizonColor, sunriseColor, smoothStep(0, 0.33, dayFactor));
    } else if (dayFactor <= 0.66) {
      return lerpColor(sunriseColor, softPurple, smoothStep(0.33, 0.66, dayFactor));
    } else {
      return lerpColor(softPurple, skyBottom, smoothStep(0.66, 1, dayFactor));
    }
  };
  const cloudColorDay   = { r:255, g:255, b:255 };
  const cloudColorNight = { r:80,  g:80,  b:100 };

  // Directional lighting
  const sunDir = { x: 0.3, y: 0.5, z: 0.7 };
  const sunMag = Math.hypot(sunDir.x, sunDir.y, sunDir.z);
  sunDir.x /= sunMag; 
  sunDir.y /= sunMag; 
  sunDir.z /= sunMag;
  const tonedDownHorizon = (horizon, base, factor=0.4) => lerpColor(horizon, base, factor);

  // --- Stars Setup (MODIFIED to use only upper hemisphere) ---
  const starCount = 500;
  const stars = [];
  for (let i = 0; i < starCount; i++) {
    // Generate a random direction in the hemisphere y>0:
    const phi = 2 * Math.PI * Math.random();
    const cosTheta = Math.random();         // range [0..1] => 0..90Â° from the top
    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);

    const x = sinTheta * Math.cos(phi);
    const y = cosTheta;   // always positive => "above horizon"
    const z = sinTheta * Math.sin(phi);

    stars.push({
      x,
      y,
      z,
      twinkleOffset: Math.random() * Math.PI * 2,
      baseBrightness: 0.8 + Math.random() * 0.4
    });
  }

  // --- Animation ---
  let time = 0, lastTime = performance.now();
  function render(){
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    time += dt;

    // Day/night factor and sky colors
    const dayFactor = 0.5 + 0.5 * Math.sin((2 * Math.PI * time) / dayCyclePeriod - Math.PI/2);
    const skyTopColor = lerpColor(nightSkyTop, daySkyTop, dayFactor);
    const skyBottomColor = lerpColor(nightSkyBottom, daySkyBottom, dayFactor);
    let horizonColor = tonedDownHorizon(computeHorizonColor(dayFactor, skyBottomColor), skyBottomColor, 0.4);
    const baseSkyColor = skyBottomColor;
    const dynamicCloudColor = lerpColor(cloudColorNight, cloudColorDay, dayFactor);

    // --- Compute Camera Basis ---
    const cosPitch = Math.cos(camera.pitch), sinPitch = Math.sin(camera.pitch);
    const cosYaw = Math.cos(camera.yaw), sinYaw = Math.sin(camera.yaw);
    const forward = { 
      x: cosPitch * sinYaw, 
      y: sinPitch, 
      z: cosPitch * cosYaw 
    };
    const right = { 
      x: Math.sin(camera.yaw - Math.PI/2), 
      y: 0, 
      z: Math.cos(camera.yaw - Math.PI/2) 
    };
    const up = {
      x: right.y * forward.z - right.z * forward.y,
      y: right.z * forward.x - right.x * forward.z,
      z: right.x * forward.y - right.y * forward.x
    };
    const scale = Math.tan(camera.fov / 2);

    // --- Draw Sky & Clouds & Void Plane (Offscreen) ---
    const wOff = offCanvas.width, hOff = offCanvas.height;
const nightAlpha = 1 - dayFactor; // 0 = full day, 1 = full night

function fadeToBlack(color, alpha) {
  return {
    r: Math.round(color.r * (1 - alpha)),
    g: Math.round(color.g * (1 - alpha)),
    b: Math.round(color.b * (1 - alpha))
  };
}

const fadedTop = fadeToBlack(skyTopColor, nightAlpha * 0.5);
const fadedBottom = fadeToBlack(skyBottomColor, nightAlpha * 0.7);

const skyGrad = offCtx.createLinearGradient(0, 0, 0, hOff);
skyGrad.addColorStop(0, `rgb(${fadedTop.r},${fadedTop.g},${fadedTop.b})`);
skyGrad.addColorStop(1, `rgb(${fadedBottom.r},${fadedBottom.g},${fadedBottom.b})`);
offCtx.fillStyle = skyGrad;
offCtx.fillRect(0, 0, wOff, hOff);

    const imgData = offCtx.getImageData(0, 0, wOff, hOff);
    const data = imgData.data;

    // Per-pixel environment pass
    for (let py = 0; py < hOff; py++) {
      const ndcY = 1 - 2 * (py / hOff);
      for (let px = 0; px < wOff; px++) {
        const ndcX = 2 * (px / wOff) - 1;
        let rayX = forward.x + ndcX * scale * camera.aspect * right.x + ndcY * scale * up.x;
        let rayY = forward.y + ndcX * scale * camera.aspect * right.y + ndcY * scale * up.y;
        let rayZ = forward.z + ndcX * scale * camera.aspect * right.z + ndcY * scale * up.z;
        const len = Math.hypot(rayX, rayY, rayZ);
        rayX /= len; 
        rayY /= len; 
        rayZ /= len;

        let col = baseSkyColor;
        if (rayY > 0) {
          // Cloud plane intersection
          let tRaw = (cloudPlaneY - camera.y) / rayY;
          const adjust = lerp(1, 5, Math.max(0, Math.min(1, (0.2 - rayY) / 0.2)));
          tRaw *= adjust;
          if (tRaw > 0) {
            const tEff = (cloudPlaneY - camera.y) * Math.pow(tRaw / (cloudPlaneY - camera.y), perspectiveExponent);
            let wx = camera.x + rayX * tEff + time * cloudSpeed;
            let wz = camera.z + rayZ * tEff + time * cloudSpeed;
            const n = fractalNoise(wx * cloudScale, wz * cloudScale);
            const cloudFactor = Math.min(Math.max((n - threshold) / 0.1, 0), 1);
            const cloudBase = {
              r: lerp(baseSkyColor.r, dynamicCloudColor.r, cloudFactor),
              g: lerp(baseSkyColor.g, dynamicCloudColor.g, cloudFactor),
              b: lerp(baseSkyColor.b, dynamicCloudColor.b, cloudFactor)
            };
            const dist = Math.min(tRaw, fogEnd);
            const fogFactor = fogBlend(dist);
            let cloudFinal = {
              r: lerp(cloudBase.r, horizonColor.r, fogFactor),
              g: lerp(cloudBase.g, horizonColor.g, fogFactor),
              b: lerp(cloudBase.b, horizonColor.b, fogFactor)
            };
            // Light from sun direction
            const light = Math.max(0, rayX * sunDir.x + rayY * sunDir.y + rayZ * sunDir.z);
            cloudFinal.r = Math.min(255, cloudFinal.r * (1 + 0.1 * light));
            cloudFinal.g = Math.min(255, cloudFinal.g * (1 + 0.1 * light));
            cloudFinal.b = Math.min(255, cloudFinal.b * (1 + 0.1 * light));
            col = cloudFinal;
          }
        } else {
          // Void plane intersection
          let tRaw = (voidPlaneY - camera.y) / rayY;
          if (tRaw > 0) {
            const dist = Math.min(tRaw, voidFogEnd);
            const distBlend = voidFogBlend(dist);
            const tonedVoid = lerpColor(horizonColor, { r:255, g:255, b:255 }, 0.2);
            col = lerpColor(baseSkyColor, tonedVoid, distBlend);
          }
        }
        const idx = (py * wOff + px) * 4;
        data[idx]   = col.r | 0;
        data[idx+1] = col.g | 0;
        data[idx+2] = col.b | 0;
        data[idx+3] = 255;
      }
    }
    offCtx.putImageData(imgData, 0, 0);

    // Draw offscreen result onto main canvas
    ctx.fillStyle = `rgb(${baseSkyColor.r},${baseSkyColor.g},${baseSkyColor.b})`;
    ctx.fillRect(0, 0, cw, ch);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offCanvas, 0, 0, cw, ch);

    // --- Draw Stars ---
    const starVisibility = 1 - dayFactor; // fade out in daylight
    if (starVisibility > 0.01) {
      // optional: distance-based fog factor for stars
      const starFogFactor = fogBlend(4000); 

      for (const s of stars) {
        // Transform star's world direction into camera space
        const cx = s.x * right.x + s.y * right.y + s.z * right.z;
        const cy = s.x * up.x    + s.y * up.y    + s.z * up.z;
        const cz = s.x * forward.x + s.y * forward.y + s.z * forward.z;

        // 1) Skip stars behind the camera
        if (cz <= 0) continue;

        // (REMOVED) old "if (cy < 0) continue;" check

        // 2) Project to screen
        const ndcX = cx / (cz * scale * camera.aspect);
        const ndcY = cy / (cz * scale);
        const sx = (ndcX + 1) * 0.5 * cw;
        const sy = (1 - ndcY) * 0.5 * ch;

        // 3) Twinkle & brightness fade
        const twinkle = 0.8 + 0.2 * Math.sin(time * 5 + s.twinkleOffset);
        const finalBrightness = s.baseBrightness * twinkle * starVisibility * (1 - starFogFactor);
        if (finalBrightness <= 0.01) continue;

        // 4) Draw star
        ctx.beginPath();
        ctx.arc(sx, sy, 1.2, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(255,255,255,${finalBrightness})`;
        ctx.fill();
      }
    }

    requestAnimationFrame(render);
  }
  render();
})();
</script>
</body>
</html>
